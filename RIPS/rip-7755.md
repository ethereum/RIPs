---
rip: 7755
title: Cross-L2-Call Specification
description: Contract standard for cross-L2 calls facilitation
author: Wilson Cusack (@WilsonCusack)
discussions-to: [Ethereum Magicians](https://ethereum-magicians.org/t/rip-contract-standard-for-cross-l2-calls-facilitation)
status: Draft
type: Standards Track
category: Core
created: 2024-08-11
---

## Abstract 
Contracts for facilitating request, fulfillment, and fulfillment reward of cross-L2 calls.

## Motivation
Cross-chain actions are an increasingly important part of crypto user experience. Today, most solutions for Ethereum layer 2s (L2s) have one or more of the following drawbacks. 
1. Reliance on privatized relayers with offchain access and incentives.
1. Reliance on protocols outside of Ethereum and its rollups. 
1. High-level, intent-based systems that do not allow specifying exact calls to make. 

Ethereum L2s, which all write state to a shared execution environment, are uniquely positioned to offer an alternative. Ethereum L2 users should have access to a public, decentralized utility for making cross L2 calls.

From any L2 chain, users should be able to request a call be made on any other L2 chain. Users should be able to guarantee a compensation for this call being made, and thus be able to control the likelihood this call will be made. 

User should have full assurance that compensation will only be paid if the call was made. This assurance should depend ONLY on onchain information. 

## Specification
To only rely on onchain information, we use
1. Layer 1 (L1), i.e. Ethereum Mainnet, blockhashes on the L2. 
    - We take as an assumption that every Ethereum L2 should have a trusted L1 blockhash in the execution environment. 
2. Ethereum L2 blockhashes on L1.
   - e.g. via an [L2 Output Oracle Contract](https://specs.optimism.io/glossary.html?#l2-output-oracle-contract)

Using these inputs, on any Ethereum L2, we can trustlessly verify [ERC-1186](https://eips.ethereum.org/EIPS/eip-1186) storage proofs of any other Ethereum L2. 

Our contracts' job, then, is to represent call requests and fulfillment in storage on each chain. 

### Structs 
```solidity 

struct Call {
  // The address to call
  address to;
  // The calldata to call with
  bytes data;
  // The native asset value of the call
  uint256 value;
}

struct CrossChainCall {
  // Array of calls to make on the destination chain
  Call[] calls;
  // The contract on origin chain where this cross-chain call request originated
  address originationContract;
  // The chainId of the origin chain
  uint256 originChainId;
  // The chainId of the destination chain
  uint256 destinationChainId;
  // The nonce of this call, to differentiate from other calls with the same values
  uint256 nonce;
  // The L2 contract on destination chain that's storage will be used to verify whether or not this call was made
  address verifyingContract;
  // The L1 address of the contract that should have L2 block info stored
  address l2Oracle;
  // The storage key at which we expect to find the L2 block info on the l2Oracle
  bytes32 l2OracleStorageKey;
  // The address of the ERC20 reward asset to be paid to whoever proves they filled this call
  // Native asset specified as in ERC-7528 format
  address rewardAsset;
  // The reward amount to pay 
  uint256 rewardAmount;
  // The minimum age of the L1 block used for the proof
  uint256 finalityDelaySeconds;
  // An optional pre-check contract address on the destination chain
  // Zero address represents no pre-check contract desired
  // Can be used for arbitrary validation of fill conditions
  address precheckContract;
  // Pre-check calldata to be used in a low-level `call` if the pre-check contract address is specified
  bytes precheckData;
}

/// @notice Stored on verifyingContract and proved against in originationContract 
struct FulfillmentInfo {
  // Block timestamp when fulfilled
  uint96 timestamp;
  // Msg.sender of fulfillment call
  address filler;
}
```
### Flow Diagrams
#### Happy Case
![image](../assets/rip-7755/happy_case.png "Happy case flow")

1. User calls to a facilitator contract with the CrossChainCall and reward funds
1. Facilitator emits event for fillers to discover
1. Filler relays CrossChainCall to verifyingContract, including any funds possibly needed to successfully complete the call
1. If included, verifyingContract makes a precheck call to validate fill condition(s)
1. verifyingContract makes the call as specified by CrossChainCall
1. verifyingContract write to storage the call, the filler, and call outcome
1. After CrossChainCall.finalityDelaySeconds have elapsed, the filler can submit the proof
1. If the proof is valid and the call was successfully made, filler is paid reward


### CrossChainCallOriginator Contract
On the origin chain, there is an origination contract to receive cross-chain call requests and payout rewards on proof of their fulfillment. 

```solidity
pragma solidity ^0.8.23;

abstract contract CrossChainCallOriginator {

  enum CrossChainCallStatus {
    None,
    Requested,
    CancelRequested,
    Canceled,
    Completed
  }

  error InvalidValue(uint expected, uint received);
  error InvalidStatusForRequestCancel(CrossChainCallStatus status);
  error InvalidStatusForFinalizeCancel(CrossChainCallStatus status);

  event CrossChainCallRequested(bytes32 indexed callHash, CrossChainCall call);
  event CrossChainCallCancelRequested(bytes32 indexed callHash);
  event CrossChainCallCancelFinalized(bytes32 indexed callHash);

  mapping (bytes32 callHash => CrossChainCallStatus status) public requestStatus;
  mapping (bytes32 callHash => uint timestampSeconds) public cancelRequestedAt;

  /// @dev The duration, in excess of 
  /// CrossChainCall.finalityDelaySeconds, which must pass
  /// between requesting and finalizing a request cancellation
  uint public cancelDelaySeconds = 1 days;

  address internal NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
  uint internal _nonce;

  function requestCrossChainCall(CrossChainCall memory crossChainCall) external payable {
    crossChainCall.nonce = ++_nonce;
    crossChainCall.originChainId = block.chainid;
    crossChainCall.originationContract = address(this);

    bytes32 hash = callHash(crossChainCall);
    requestStatus[hash] = CrossChainCallStatus.Requested;

    if (crossChainCall.rewardAsset == NATIVE_ASSET) {
      if (crossChainCall.rewardAmount != msg.value) {
        revert InvalidValue(crossChainCall.rewardAmount, msg.value);
      }
    } else {
      _pullERC20(msg.sender, crossChainCall.rewardAsset, crossChainCall.rewardAmount);
    }

    emit CrossChainCallRequested(hash, crossChainCall);
  }

  function claimReward(CrossChainCall calldata crossChainCall, FulfillmentInfo calldata fillInfo, bytes calldata storageProofData, address payTo) external payable {  
    bytes32 hash = callHashCalldata(crossChainCall);
    bytes32 storageKey = keccak256(
      abi.encodePacked(
        hash,
        uint(0) // Must be at slot 0
      )
    );
    
    _validate(storageKey, fillInfo, crossChainCall, storageProofData);
    requestStatus[hash] = CrossChainCallStatus.Completed;
    
    if (crossChainCall.rewardAsset == NATIVE_ASSET) {
      payable(payTo).call{value: crossChainCall.rewardAmount, gas: 100_000}("");
    } else { 
        _sendERC20(payTo, crossChainCall.rewardAsset, crossChainCall.rewardAmount);
    }

  }

  function requestCancel(CrossChainCall calldata crossChainCall) external {
    bytes32 hash = callHashCalldata(crossChainCall);
    CrossChainCallStatus status = requestStatus[hash];
    if (status != CrossChainCallStatus.Requested) {
      revert InvalidStatusForRequestCancel(status);
    }

    requestStatus[hash] = CrossChainCallStatus.CancelRequested;

    emit CrossChainCallCancelRequested(hash);
  }

  function finalizeCancel(CrossChainCall calldata crossChainCall) external {
    bytes32 hash = callHashCalldata(crossChainCall);
    CrossChainCallStatus status = requestStatus[hash];
    if (status != CrossChainCallStatus.CancelRequested) {
      revert InvalidStatusForFinalizeCancel(status);
    }

    requestStatus[hash] = CrossChainCallStatus.Canceled;

    emit CrossChainCallCancelFinalized(hash);
  }

  function callHash(CrossChainCall memory crossChainCall) public pure returns (bytes32) {
    return keccak256(abi.encode(crossChainCall));
  }

  function callHashCalldata(CrossChainCall calldata crossChainCall) public pure returns (bytes32) {
    return keccak256(abi.encode(crossChainCall));
  }

  /// @notice Validates storage proofs and verifies fill 
  /// @custom:reverts If storage proof invalid.
  /// @custom:reverts If fillInfo not found at verifyingContractStorageKey on crossChainCall.verifyingContract
  /// @custom:reverts If fillInfo.timestamp is less than 
  /// crossChainCall.finalityDelaySeconds from current destination chain block timestamp.
  /// @dev Implementation will vary by L2
  function _validate(bytes32 verifyingContractStorageKey, FulfillmentInfo calldata fillInfo, CrossChainCall calldata crossChainCall, bytes calldata storageProofData) internal  view virtual;

  /// @notice Pulls `amount` of `asset` from `owner` to address(this)
  /// @dev Left abstract to minimize imports and maximize simplicity for this example
  function _pullERC20(address owner, address asset, uint256 amount) internal virtual;

  /// @notice Sends `amount` of `asset` to `to`
  /// @dev Left abstract to minimize imports and maximize simplicity for this example
  function _sendERC20(address to, address asset, uint256 amount) internal virtual;
}
```

### CrossChainCallFulfillment Contract
On the destination chain, there is a `CrossChainCallFulfillment` contract to facilitate store proof of call fulfillment.

```solidity
contract CrossChainCallFulfillment {
  error InvalidChainId();
  error InvalidVerifyingContract();
  error CallAlreadyFulfilled();

  event CallFulfilled(bytes32 indexed callHash, address indexed fulfilledBy);

  mapping(bytes32 callHash => FulfillmentInfo) public fillInfo;

  function fulfill(CrossChainCall calldata crossChainCall) external {
      if (block.chainid != crossChainCall.destinationChainId) {
          revert InvalidChainId();
      }

      if (address(this) != crossChainCall.verifyingContract) {
          revert InvalidVerifyingContract();
      }

      // Run precheck - call expected to revert if precheck condition(s) not met.
      if (crossChainCall.precheckContract != address(0)) {
        _call(crossChainCall.precheckContract, 0, crossChainCall.precheckData);
      }

      // TODO: Check for trusted originationContract 

      bytes32 callHash = callHashCalldata(crossChainCall);

      if (fillInfo[callHash].timestamp != 0) {
        revert CallAlreadyFulfilled();
      }

      for (uint256 i; i < crossChainCall.calls.length; i++) {
          _call(crossChainCall.calls[i].to, crossChainCall.calls[i].value, crossChainCall.calls[i].data);
      }

      fillInfo[callHash] = FulfillmentInfo({
        timestamp: uint96(block.timestamp),
        filler: msg.sender
      });

      emit CallFulfilled({
          callHash: callHash,
          fulfilledBy: msg.sender
      });
  }

  function callHashCalldata(CrossChainCall calldata crossChainCall) public pure returns (bytes32) {
      return keccak256(abi.encode(crossChainCall));
  }

  function _call(address target, uint256 value, bytes memory data) internal {
      (bool success, bytes memory result) = target.call{value: value}(data);
      if (!success) {
          assembly ("memory-safe") {
              revert(add(result, 32), mload(result))
          }
      }
  }
}
```

## Example Usage
_These examples are not intended to be comprehensive of every detail. First example is more verbose, in hopes of giving helpful understanding for all examples._
### Transfer native asset across chains. 
**User at Address A on Chain X wants to send 0.1 ether to Address B on Chain Y.** 

On Chain X, Address A calls `requestCrossChainCall` on a `CrossChainCallOriginator` contract of their choosing. CrossChainCall.calls contains a single call. 
```solidity 
Call({
  to: <Address B>,
  value: 0.1 ether, 
  data: ""
})
```

The `CrossChainCall` includes info about the origin chain, destination chain, and `CrossChainCallFulfillment` contract the user wants the call to be made through on destination chain. 

The destination chain has a 7 day challenge period, and so the user sets `CrossChainCall.finalityDelaySeconds` to a 7 day equivalent for maximum security. 

When calling to `requestCrossChainCall` on origin chain, the user sends 0.1001 ether in value, which matches `CrossChainCall.rewardAmount`. The excess above 0.1 ether is intended to exceed the gas cost of the call on destination chain and serve as a compensation to the filler. This reward amount would need to provide sufficient incentive for the filler to wait `CrossChainCall.finalityDelaySeconds`, in this case 7 days, to get their reward. 

### Transfer ERC20 asset across chains. 
**User at Address A on Chain X wants to send 100 USDC to Address B on Chain Y.**

ERC20 transfers have unique challenges in our paradigm, because

<ol type="A">
  <li>The caller needs to specify the exact calls to make.</li>
  <li>The calls must be made through the verifyingContract.</li>
</ol>

We show two example solutions below. 

#### 1. With known filler address
The following example requires the caller to know ahead of time the fillers address. This is not ideal because (1) the calls will only work for one filler (2) requires offchain pre-coordination. 

- Origin Chain: 
  - Pre-steps: 
    - Address A calls to USDC contract on origination chain to approve `CrossChainCall.originationContract` to move 100 USDC.
  - Address A calls to originationContract, with a two calls in `CrossChainCall.calls` 
    - ```solidity 
        Call({
          to: <USDC contract on destination chain>,
          value: 0, 
          data: abi.encodeWithSelector(ERC20.transferFrom.selector, <filler address>, <CrossChainCallFulfillment contract address>, 100 * (10 ** USDC.decimals()))
        })
      ```
    - ```solidity 
        Call({
          to: <USDC contract on destination chain>,
          value: 0, 
          data: abi.encodeWithSelector(ERC20.transfer.selector, <Address B>, 100 * (10 ** USDC.decimals()))
        })
      ```
- Destination Chain 
  - Pre-steps
     - Filler calls to USDC contract on destination chain to approve `CrossChainCall.verifyingContract` to move 100 USDC.
  - Filler calls `fulfill` on `CrossChainCall.verifyingContract`
    - In the first call of `CrossChainCall.calls`, 100 USDC is sent from filler to `CrossChainCall.verifyingContract`. 
    - In second call, 100 USDC is sent from `CrossChainCall.verifyingContract` to Address B.

#### 2. With helper contract
We could also solve the challenge by introducing a helper contract for facilitating the ERC20 transfer. This helper contract would accept calls in the format `transfer(address asset, address to, uint256 amount)` and then would use `tx.origin` to determine the `from` for the ERC20 `transferFrom` call (and check `msg.sender` is some known `verifyingContract`). This would rely on fillers pre-depositing ERC20s in this helper contract, or having approvals set so it can pull funds at any time. 

> [!NOTE]  
> In future drafts, we may specify an implementation of `HelperContract`. It may also be convenient for fillers to be able to auth with signature. This could maybe be accomplished via some `context` that could be passed to `fulfill` and stored in `verifyingContract` for the duration of the call. 

- Origin Chain: 
  - Pre-steps: 
    - Address A calls to USDC contract on origination chain to approve `CrossChainCall.originationContract` to move 100 USDC.
  - Address A calls to originationContract, with a one call in `CrossChainCall.calls` 
    - ```solidity 
        Call({
          to: <USDC contract on destination chain>,
          value: 0, 
          data: abi.encodeWithSelector(HelperContract.transfer.selector, CrossChainCall.rewardAsset, <Address B>, 100 * (10 ** USDC.decimals()))
        })
      ```
- Destination Chain 
  - Pre-steps
     - Filler calls to USDC contract on destination chain to approve `HelperContract` to move 100 USDC.
  - Filler calls `fulfill` on `CrossChainCall.verifyingContract`
    - Call transfers 100 USDC to Address B via `HelperContract`.

### ERC20 swap on Chain B using assets from Chain A.
TODO
### Pay gas on Chain A for a smart account transaction on Chain B. 
TODO

## Example _validate implementation parameter construction

### OP Stack 
TODO
### Arbitrum 
TODO