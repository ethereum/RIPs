---
rip: 7755
title: Cross-L2-Call
description: Contract standard for cross-L2 calls facilitation
author: Wilson Cusack (@WilsonCusack), Jack Chuma (@jackchuma)
discussions-to: https://ethereum-magicians.org/t/rip-contract-standard-for-cross-l2-calls-facilitation
status: Draft
type: Standards Track
category: Core
created: 2024-08-11
---

## Abstract

Contracts for facilitating request, fulfillment, and fulfillment reward of cross-L2 calls.

## Motivation

Cross-chain actions are an increasingly important part of crypto user experience. Today, most solutions for Ethereum layer 2s (L2s) have one or more of the following drawbacks.

1. Reliance on privatized relayers with offchain access and incentives.
1. Reliance on protocols outside of Ethereum and its rollups.
1. High-level, intent-based systems that do not allow specifying exact calls to make.

Ethereum L2s, which all write state to a shared execution environment, are uniquely positioned to offer an alternative. Ethereum L2 users should have access to a public, decentralized utility for making cross L2 calls.

From any L2 chain, users should be able to request a call be made on any other L2 chain. Users should be able to guarantee a compensation for this call being made, and thus be able to control the likelihood this call will be made.

Users should have full assurance that compensation will only be paid if the call was made. This assurance should depend ONLY on onchain information.

## Specification

To only rely on onchain information, we use

1. Layer 1 (L1), i.e. Ethereum Mainnet, blockhashes or beacon roots on the L2.
   - We take as an assumption that every Ethereum L2 should have a trusted L1 blockhash or state representation in the execution environment.
1. Ethereum L2 blockhashes or state roots on L1.

Using these inputs, on any Ethereum L2, we can trustlessly verify ERC-1186 storage proofs of any other Ethereum L2.

Our contracts' job, then, is to represent call requests and fulfillment in storage on each chain.

### Flow Diagrams

#### Happy Case

![image](../assets/rip-7755/happy_case.png "Happy case flow")

1. User calls to an `RIP7755Outbox` contract with `CrossChainRequest` and reward funds
1. `RIP7755Outbox` emits event for fulfillers to discover
1. Fulfiller relays `CrossChainRequest` to `RIP7755Inbox` contract, including any funds possibly needed to successfully complete the call
1. If included, `RIP7755Inbox` makes a precheck call to validate fulfillment condition(s)
1. `RIP7755Inbox` makes the call as specified by `CrossChainRequest`
1. `RIP7755Inbox` write to storage the `FulfillmentInfo` receipt of the call
1. After `CrossChainRequest.finalityDelaySeconds` have elapsed, the fulfiller can submit the proof
1. If the proof is valid and the call was successfully made, fulfiller is paid reward

> [!NOTE]
>
> - The following specifications use syntax from Solidity `0.8.14` (or above).
> - To add support for non-EVM chains, all `address` types are converted to `bytes32`.

### Data Structures

#### Call

Low-level call specs representing the desired transaction on destination chain.

Fields:

- `to`: The address to call
- `data`: The calldata to call with
- `value`: The native asset value of the call

```solidity
struct Call {
    bytes32 to;
    bytes data;
    uint256 value;
}
```

#### CrossChainRequest

A cross chain call request detailing information about the call's origin, destination, exact calls to make, and information needed to verify the call was made.

Fields:

- `requester`: The account submitting the cross chain request
- `calls`: The calls to make on the destination chain
- `sourceChainId`: The chainId of the source chain
- `origin`: The contract address the request was submitted to
- `destinationChainId`: The chainId of the destination chain
- `inboxContract`: The L2 contract on destination chain that's storage will be used to verify whether or not this call was made
- `l2Oracle`: The L1 address of the contract that should have L2 block info stored
- `rewardAsset`: The address of the ERC20 reward asset to be paid to whoever proves they filled this call. Native asset specified as in ERC-7528 format.
- `rewardAmount`: The reward amount to pay
- `finalityDelaySeconds`: The minimum age of the L1 block used for the proof
- `nonce`: The nonce of this call, to differentiate from other calls with the same values
- `expiry`: The timestamp at which this request will expire
- `extraData`: Extra data to be included in the proof - this is extra data to be used for prechecks and special validation cases. The first element in the `extraData` array is reserved for the precheck. If no precheck is desired, set to an empty array. If no precheck is desired but other data is needed, set the first element in the array to the zero address.

```solidity
struct CrossChainRequest {
    bytes32 requester;
    Call[] calls;
    uint256 sourceChainId;
    bytes32 origin;
    uint256 destinationChainId;
    bytes32 inboxContract;
    bytes32 l2Oracle;
    bytes32 rewardAsset;
    uint256 rewardAmount;
    uint256 finalityDelaySeconds;
    uint256 nonce;
    uint256 expiry;
    bytes[] extraData;
}
```

### Outbox

On the origin chain, there is an outbox contract to receive cross-chain call requests and payout rewards on proof of their fulfillment that must adhere to the following interface.

#### Events

##### CrossChainCallRequested

MUST trigger when a user requests a cross chain call to be made by a fulfiller.

Parameters:

- `requestHash`: The keccak256 hash of a `CrossChainRequest`
- `request`: The requested cross chain call

```solidity
event CrossChainCallRequested(bytes32 indexed requestHash, CrossChainRequest request);
```

##### CrossChainCallCompleted

MUST trigger when a fulfiller claims their reward for a cross chain call.

Parameters:

- `requestHash`: The keccak256 hash of a `CrossChainRequest`
- `submitter`: The address of the fulfiller that successfully completed the cross chain call

```solidity
event CrossChainCallCompleted(bytes32 indexed requestHash, address submitter);
```

##### CrossChainCallCanceled

MUST trigger when an expired request is canceled.

Parameters:

- `requestHash`: The keccak256 hash of a `CrossChainRequest`

```solidity
event CrossChainCallCanceled(bytes32 indexed requestHash);
```

#### Methods

##### requestCrossChainCall

Submits an RIP-7755 request for a cross chain call. MUST emit a `CrossChainCallRequested` event. MUST lock the request reward amount in the contract.

```solidity
function requestCrossChainCall(CrossChainRequest memory request) external payable;
```

##### claimReward

To be called by a fulfiller that successfully submitted a cross chain request to the destination chain and can prove it with a valid nested storage proof. MUST emit a `CrossChainCallCompleted` event. MUST send the request reward to the `payTo` address.

```solidity
function claimReward(CrossChainRequest calldata request, bytes calldata proof, address payTo) external;
```

##### cancelRequest

Cancels a pending request that has expired. MUST emit a `CrossChainCallCanceled` event. MUST send the request reward back to the original requester.

```solidity
function cancelRequest(CrossChainRequest calldata request) external;
```

### Inbox

On the destination chain, there is an inbox contract used as a router for the requested calls and to store a receipt of the request fulfillment.

#### Data Structures

##### FulfillmentInfo

Stores information about the fulfillment of a request.

Fields:

- `timestamp`: The block timestamp when the request was fulfilled
- `filler`: The address of the fulfiller that successfully completed the call

```solidity
struct FulfillmentInfo {
    uint96 timestamp;
    address filler;
}
```

#### Events

##### CallFulfilled

MUST emit when a cross chain call request is fulfilled.

Parameters:

- `requestHash`: The keccak256 hash of a `CrossChainRequest`
- `fulfilledBy`: The address of the fulfiller that successfully completed the call

```solidity
event CallFulfilled(bytes32 indexed requestHash, address indexed fulfilledBy);
```

#### Methods

##### fulfill

Routes the requested calls to the specified destinations and stores a receipt of the fulfillment. MUST emit a `CallFulfilled` event. Once the `FulfillmentInfo` is written to storage, this receipt MUST be considered immutable. This is critical for storage proof validation to work reliably.

Note: A custom fulfiller address is specified by the caller to allow flexibility for a separate address to be used for claiming rewards.

```solidity
function fulfill(CrossChainRequest calldata request, address fulfiller) external payable;
```

### Precheck

If the first element of `CrossChainRequest.extraData` is not the zero address, its first 20 bytes are interpreted as the address of a precheck contract. The precheck contract is called with the request and caller address. The precheck contract can validate any arbitrary conditions that should be true for the call to be made.

#### Methods

##### precheckCall

Called by the `fulfill` function to validate the request. `caller` is the address of the fulfiller that submitted the transaction to `RIP7755Inbox`.

```solidity
function precheckCall(CrossChainRequest calldata request, address caller) external;
```

### Storage Proof Validation

The implementation details for successful storage proof validation will vary depending on the destination chain. This is why the `proof` input parameter is passed into the `claimReward` function in the `Outbox` contract above as an arbitrary `bytes` type. Each individual implementation MAY have subtle differences in the expected format of the proof. However, all implementations SHALL adhere to the following fundamental pattern:

![image](../assets/rip-7755/state_root_sharing.png "Storage proof validation")

> [!NOTE]
> In the above image, networks have a gray background, contracts have a purple background and storage values have a yellow background.
>
> Source chain: Chain A \
> Destination chain: Chain B

1. Verify that the beacon root used for the proof corresponds to the root exposed in Chain A's execution environment.
1. Validate L1 execution client's state root against the beacon root.
1. Validate Chain B's rollup contract storage root against L1 execution client's state root.
1. Validate Chain B's state root against Chain B's rollup contract storage root.
1. Validate Chain B's inbox contract storage root against Chain B's state root.
1. Validate the `FulfillmentInfo` struct at the correct storage key against Chain B's inbox contract storage root.

It is important to note that not all L2 chains directly store their state root on L1. In certain cases, the L2 chain stores an abstract "output root" which must be connected to its state root in some manner. In these instances, the storage proof validation necessitates an intermediate step between steps 4 and 5. This step involves providing the destination chain's state root along with custom logic to derive the output root using that state root and any other required information. This step is only considered successful if the derived output root matches the value proven to be stored in the destination chain's inbox contract on L1.

### Example Usage

_These examples are not intended to be comprehensive of every detail. First example is more verbose, in hopes of giving helpful understanding for all examples._

#### Transfer native asset across chains.

**User at Address A on Chain X wants to send 0.1 ether to Address B on Chain Y.**

On Chain X, Address A calls `requestCrossChainCall` on a `RIP7755Outbox` contract of their choosing. `CrossChainRequest.calls` contains a single call.

```solidity
Call({
  to: <Address B>.toBytes32(),
  value: 0.1 ether,
  data: ""
})
```

The `CrossChainRequest` includes info about the destination chain and `RIP7755Inbox` contract the user wants the call to be made through.

The destination chain has a 7 day challenge period, and so the user sets `CrossChainRequest.finalityDelaySeconds` to a 7 day equivalent for maximum security.

When calling to `requestCrossChainCall` on origin chain, the user sends 0.1001 ether in value, which matches `CrossChainRequest.rewardAmount`. The excess above 0.1 ether is intended to exceed the gas cost of the call on destination chain and serve as a compensation to the fulfiller. This reward amount would need to provide sufficient incentive for the fulfiller to wait `CrossChainRequest.finalityDelaySeconds`, in this case 7 days, to get their reward.

**Include custom exclusivity period for a specified fulfiller**

To enhance the previous example, we introduce a precheck condition where Address A authorizes only a specific fulfiller, referred to as Fulfiller A, to submit the transaction to the destination chain for a specified period of time.

To implement this, custom exclusivity logic must be incorporated into a precheck smart contract (PCSM) deployed on the destination chain. The `CrossChainRequest` will include the PCSM address concatenated with the encoded data for exclusivity validation in the `extraData` field.

```solidity
    CrossChainCall({
      ...
      extraData: abi.encodePacked(<PCSM address on destination chain>, abi.encode(<fulfiller address>, expirationTimestamp)),
      ...
    })
```

Once Address A invokes `requestCrossChainCall` on the origin chain, if an unintended fulfiller attempts to submit the transaction on the destination chain within the exclusivity period, the `fulfill` function call will revert due to the precheck failure. This ensures that only Fulfiller A can call `fulfill` before the `expirationTimestamp`.

#### Transfer ERC20 asset across chains.

**User at Address A on Chain X wants to send 100 USDC to Address B on Chain Y.**

ERC20 transfers have unique challenges in our paradigm, because

<ol type="A">
  <li>The caller needs to specify the exact calls to make.</li>
  <li>The calls must be made through the inbox contract.</li>
</ol>

We show two example solutions below.

##### 1. With known fulfiller address

The following example requires the caller to know ahead of time the fulfillers address. This is not ideal because (1) the calls will only work for one fulfiller (2) requires offchain pre-coordination.

- Origin Chain:
  - Pre-steps:
    - Address A calls to USDC contract on origination chain to approve `RIP7755Outbox` to move 100 USDC.
  - Address A calls to outbox, with a two calls in `CrossChainRequest.calls`
    - ```solidity
        Call({
          to: <USDC contract on destination chain>.toBytes32(),
          value: 0,
          data: abi.encodeWithSelector(ERC20.transferFrom.selector, <fulfiller address>, <RIP7755Inbox contract address>, 100 * (10 ** USDC.decimals()))
        })
      ```
    - ```solidity
        Call({
          to: <USDC contract on destination chain>.toBytes32(),
          value: 0,
          data: abi.encodeWithSelector(ERC20.transfer.selector, <Address B>, 100 * (10 ** USDC.decimals()))
        })
      ```
- Destination Chain
  - Pre-steps
    - Fulfiller calls to USDC contract on destination chain to approve `RIP7755Inbox` to move 100 USDC.
  - Fulfiller calls `fulfill` on `RIP7755Inbox`
    - In the first call of `CrossChainRequest.calls`, 100 USDC is sent from fulfiller to `RIP7755Inbox`.
    - In second call, 100 USDC is sent from `RIP7755Inbox` to Address B.

##### 2. With helper contract

We could also solve the challenge by introducing a helper contract for facilitating the ERC20 transfer. This helper contract would accept calls in the format `transfer(address asset, address to, uint256 amount)` and then would use `tx.origin` to determine the `from` for the ERC20 `transferFrom` call (and check `msg.sender` is some known `RIP7755Inbox` contract). This would rely on fulfillers pre-depositing ERC20s in this helper contract, or having approvals set so it can pull funds at any time.

> [!NOTE]  
> In future drafts, we may specify an implementation of `HelperContract`. It may also be convenient for fulfillers to be able to auth with signature. This could maybe be accomplished via some `context` that could be passed to `fulfill` and stored in `RIP7755Inbox` for the duration of the call.

- Origin Chain:
  - Pre-steps:
    - Address A calls to USDC contract on origination chain to approve `RIP7755Outbox` to move 100 USDC.
  - Address A calls to outbox, with a one call in `CrossChainRequest.calls`
    - ```solidity
        Call({
          to: <USDC contract on destination chain>.toBytes32(),
          value: 0,
          data: abi.encodeWithSelector(HelperContract.transfer.selector, CrossChainRequest.rewardAsset, <Address B>, 100 * (10 ** USDC.decimals()))
        })
      ```
- Destination Chain
  - Pre-steps
    - Fulfiller calls to USDC contract on destination chain to approve `HelperContract` to move 100 USDC.
  - Fulfiller calls `fulfill` on `RIP7755Inbox`
    - Call transfers 100 USDC to Address B via `HelperContract`.

## Rationale

## Reference Implementation

- [Outbox](../assets/rip-7755/Outbox.md)
- [Inbox](../assets/rip-7755/Inbox.md)

#### Storage Proof Examples

The following library is an example of how storage proof validation can be implemented for an OP Stack chain.

- [OPStackProver](../assets/rip-7755/OPStackProver.md)

Where the `StateValidator` structs are defined as follows:

```solidity
/// @notice Parameters needed to validate the authenticity of Ethereum's execution client's state root
struct StateProofParameters {
    /// @dev The Beacon Chain root published to `BEACON_ROOTS_ORACLE` on this L2 chain
    bytes32 beaconRoot;
    /// @dev The timestamp associated with the provided Beacon Root
    uint256 beaconOracleTimestamp;
    /// @dev The state root of Ethereum's execution client
    bytes32 executionStateRoot;
    /// @dev A proof to verify the authenticity of `executionStateRoot`
    bytes32[] stateRootProof;
}

/// @notice Parameters needed to validate the authenticity of an EVM account's storage
struct AccountProofParameters {
    /// @dev The storage location to validate
    bytes storageKey;
    /// @dev The expected value at the specified storage location
    bytes storageValue;
    /// @dev A proof used to derive an account's storage root
    bytes[] accountProof;
    /// @dev A proof to validate the account's `storageValue` at `storageKey` location
    bytes[] storageProof;
}
```

This implementation example is designed with the assumption that the chain it is deployed on supports EIP-4788. It adheres to the general storage proof validation pattern previously outlined. The following lines highlight the specifics that are unique to the OP Stack:

```solidity
bytes32 version;
// Extract the L2 stateRoot and timestamp from the RLP-encoded block array
(bytes32 l2StateRoot, uint256 l2Timestamp) = proofData.encodedBlockArray.extractStateRootAndTimestamp();
// Derive the L2 blockhash
bytes32 l2BlockHash = proofData.encodedBlockArray.toBlockHash();

// Compute the expected destination chain output root (which is the value we just proved is in the L1 storage slot)
bytes32 expectedOutputRoot =
    keccak256(abi.encodePacked(version, l2StateRoot, proofData.l2MessagePasserStorageRoot, l2BlockHash));
// If this checks out, it means we know the correct l2StateRoot
if (bytes32(proofData.dstL2StateRootProofParams.storageValue) != expectedOutputRoot) {
    revert InvalidL2StateRoot();
}
```

This example leverages Optimism's `AnchorStateRegistry` contract to utilize the most recent anchor state available at the time of proof. The anchor state represents the finalized state of the destination L2 chain. To verify the state root of the destination chain, we must provide the pre-image of the chain's anchor state output root. As of this writing, the pre-image consists of four `bytes32` values: `version`, `l2StateRoot`, `l2MessagePasserStorageRoot`, and `l2BlockHash`.

The `l2StateRoot` and `l2BlockHash` are extracted and derived from the RLP-encoded block headers array. Specifically, the `l2StateRoot` is the fourth element in this array, while the `l2BlockHash` is the hash of the entire RLP-encoded block headers array. With this information, we can compute the expected output root.

If the derived output root does not match the value stored in the L1 storage slot, the proof is deemed invalid.

#### Arbitrum

The following library is an example of how storage proof validation can be implemented for Arbitrum.

- [ArbitrumProver](../assets/rip-7755/ArbitrumProver.md)

The process of verifying this proof is similar to the OP Stack example, but with specific nuances for Arbitrum. Below are the lines of code that are tailored for Arbitrum's unique architecture:

```solidity
// Derive the L2 blockhash
bytes32 l2BlockHash = proofData.encodedBlockArray.toBlockHash();
// Derive the RBlock's `confirmData` field
bytes32 confirmData = keccak256(abi.encodePacked(l2BlockHash, proofData.sendRoot));
// Extract the L2 stateRoot and timestamp from the RLP-encoded block array
(bytes32 l2StateRoot, uint256 l2Timestamp) = proofData.encodedBlockArray.extractStateRootAndTimestamp();

// The L1 storage value we proved was the node's confirmData
if (bytes32(proofData.dstL2StateRootProofParams.storageValue) != confirmData) {
    revert InvalidConfirmData();
}
```

This step is crucial for verifying the authenticity of the destination L2 chain's state root. In Arbitrum, the `confirmData` field within an RBlock is utilized as the L1 storage value that we have proven. Similar to the OP Stack example, we must derive the expected storage value on L1 using the state root. Specifically, this is achieved by hashing the `l2BlockHash` together with the `sendRoot` found in the proof data structure. Given that the L2 state root is included in the pre-image of the block hash, a match between the derived value and the verified storage value confirms the authenticity of the state root.

## Security Considerations

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
