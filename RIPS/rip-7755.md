---
rip: 7755
title: Cross-L2-Call
description: Contract standard for cross-L2 calls facilitation
author: Wilson Cusack (@WilsonCusack), Jack Chuma (@jackchuma)
discussions-to: https://ethereum-magicians.org/t/rip-contract-standard-for-cross-l2-calls-facilitation
status: Draft
type: Standards Track
category: Core
created: 2024-08-11
---

## Abstract

This proposal introduces a standard for facilitating cross-L2 calls within the Ethereum ecosystem. It leverages state sharing between Ethereum and its rollups to enable trustless verification of storage proofs across L2 chains. The standard defines a set of contracts, `RIP7755Outbox` and `RIP7755Inbox`, which handle the request and fulfillment of cross-chain calls. Users can request calls on any L2 chain and guarantee compensation for successful execution, ensuring decentralized and secure cross-chain interactions. The proposal aims to eliminate reliance on offchain relayers and external protocols, providing a robust and fully onchain solution for cross-L2 communication.

## Motivation

Cross-chain interactions are fundamental to modern cryptocurrency user experience. Current solutions for Ethereum L2 networks face several key limitations:

1. Dependence on centralized relayers requiring off-chain infrastructure and economic incentives
1. Reliance on protocols external to Ethereum and its rollups
1. Abstracted, intent-based architectures that restrict direct control over execution

Ethereum L2s, which all record state in a shared execution environment, are well-suited to provide an alternative. Users of Ethereum L2s should have access to a public, decentralized utility for executing cross-L2 calls.

From any L2 chain, users should be able to initiate a call on any other L2 chain. They should be able to ensure compensation for the execution of this call, thereby influencing the probability of its execution.

Users must have complete assurance that compensation is only provided if the call is executed. This assurance should rely solely on on-chain information.

## Specification

The system relies exclusively on two on-chain verification sources:

1. Layer 2 (L2) verification of Layer 1 (Ethereum Mainnet) data:
   - Blockhashes
   - Beacon chain roots
   - _Assumption_: All Ethereum L2s maintain trusted L1 state representations
2. Layer 1 verification of Layer 2 data:
   - Blockhashes
   - State roots

This bidirectional verification enables trustless ERC-1186 storage proof validation between any Ethereum L2s.

The system implements cross-chain communication through paired contracts that manage:

- Request registration and execution verification on the source chain
- Request fulfillment and receipt storage on the destination chain

### Request Flow

![image](../assets/rip-7755/happy_case.png "Happy case flow")

1. User submits `CrossChainRequest` with reward funds to `RIP7755Outbox`
1. `RIP7755Outbox` emits discovery event
1. Fulfiller relays `CrossChainRequest` to destination chain's `RIP7755Inbox`, including any required execution funds
1. `RIP7755Inbox` performs pre-execution validation (if specified)
1. `RIP7755Inbox` executes the requested cross-chain calls
1. `RIP7755Inbox` stores `FulfillmentInfo` receipt in contract storage
1. After `finalityDelaySeconds`, fulfiller submits proof
1. Upon successful proof validation, reward is released

> [!NOTE]
>
> - The following specifications use syntax from Solidity `0.8.24` (or above).

### Data Structures

#### Call

Represents a low-level call specification for a transaction on the destination chain.

Fields:

- `to`: Address to be called
- `data`: Calldata for the call
- `value`: Native asset value for the call

```solidity
struct Call {
    bytes32 to;
    bytes data;
    uint256 value;
}
```

#### CrossChainRequest

Details a cross-chain call request, including origin, destination, specific calls, and verification information.

Fields:

- `requester`: Account submitting the cross-chain request.
- `calls`: Calls to execute on the destination chain.
- `sourceChainId`: Chain ID of the source chain.
- `origin`: Contract address where the request was submitted.
- `destinationChainId`: Chain ID of the destination chain.
- `inboxContract`: L2 contract on the destination chain for verifying call execution.
- `l2Oracle`: L1 contract address storing destination L2 block information.
- `rewardAsset`: ERC20 reward asset address for proof completion, specified in ERC-7528 format.
- `rewardAmount`: Amount of the reward.
- `finalityDelaySeconds`: Minimum age of the L1 block for proof.
- `nonce`: Unique identifier to differentiate calls with identical parameters.
- `expiry`: Expiration timestamp for the request.
- `extraData`: Additional data for proof, prechecks, and special validation. The first element is reserved for prechecks; use an empty array if not needed. If other data is required without a precheck, set the first element to the zero address.

```solidity
struct CrossChainRequest {
    bytes32 requester;
    Call[] calls;
    uint256 sourceChainId;
    bytes32 origin;
    uint256 destinationChainId;
    bytes32 inboxContract;
    bytes32 l2Oracle;
    bytes32 rewardAsset;
    uint256 rewardAmount;
    uint256 finalityDelaySeconds;
    uint256 nonce;
    uint256 expiry;
    bytes[] extraData;
}
```

### Outbox

The Outbox contract, deployed on the origin chain, manages cross-chain call requests and reward distributions. It validates request fulfillment through storage proofs and must implement the following interface.

#### Events

##### CrossChainCallRequested

Emitted when a user initiates a cross-chain call request.

**Parameters:**

- `requestHash` (bytes32, indexed): Keccak256 hash of the `CrossChainRequest`
- `request` (CrossChainRequest): Cross-chain call specification

```solidity
event CrossChainCallRequested(bytes32 indexed requestHash, CrossChainRequest request);
```

##### CrossChainCallCompleted

Emitted when a fulfiller successfully claims their reward for executing a cross-chain call.

**Parameters:**

- `requestHash` (bytes32, indexed): Keccak256 hash of the `CrossChainRequest`
- `submitter` (address): Address of the successful fulfiller

```solidity
event CrossChainCallCompleted(bytes32 indexed requestHash, address submitter);
```

##### CrossChainCallCanceled

Emitted when an expired request is canceled.

**Parameters:**

- `requestHash` (bytes32, indexed): Keccak256 hash of the `CrossChainRequest`

```solidity
event CrossChainCallCanceled(bytes32 indexed requestHash);
```

#### Methods

##### requestCrossChainCall

Initiates an RIP-7755 cross-chain call request.

**Requirements:**

- Must emit `CrossChainCallRequested`
- Must lock the reward amount in the contract

```solidity
function requestCrossChainCall(CrossChainRequest memory request) external payable;
```

##### claimReward

Allows fulfillers to claim rewards by providing proof of successful cross-chain execution.

**Requirements:**

- Must verify the nested storage proof
- Must emit `CrossChainCallCompleted` event
- Must transfer reward to the specified `payTo` address

```solidity
function claimReward(CrossChainRequest calldata request, bytes calldata proof, address payTo) external;
```

##### cancelRequest

Cancels an expired request and refunds the reward.

**Requirements:**

- Must verify request expiration
- Must emit `CrossChainCallCanceled`
- Must refund reward to original requester

```solidity
function cancelRequest(CrossChainRequest calldata request) external;
```

### Inbox

The inbox contract on the destination chain functions as a router for requested calls and maintains a receipt of request fulfillment.

#### Data Structures

##### FulfillmentInfo

This structure holds details about the fulfillment of a request.

Fields:

- `timestamp`: The block timestamp when the request was fulfilled.
- `fulfiller`: The address of the entity that successfully completed the call.

```solidity
struct FulfillmentInfo {
    uint96 timestamp;
    address fulfiller;
}
```

#### Events

##### CallFulfilled

This event is emitted when a cross-chain call request is fulfilled.

**Parameters**:

- `requestHash`: The keccak256 hash of a `CrossChainRequest`.
- `fulfilledBy`: The address of the entity that successfully completed the call.

```solidity
event CallFulfilled(bytes32 indexed requestHash, address indexed fulfilledBy);
```

#### Methods

##### fulfill

This method routes the requested calls to specified destinations and records a receipt of the fulfillment.

**Requirements:**

- Must emit `CallFulfilled` event
- Once `FulfillmentInfo` is stored, the receipt is immutable

Note: The caller specifies a custom fulfiller address, allowing a different address to claim rewards.

```solidity
function fulfill(CrossChainRequest calldata request, address fulfiller) external payable;
```

### Precheck

The precheck mechanism provides customizable validation logic for cross-chain requests. When `CrossChainRequest.extraData` contains a non-zero address in its first element, the system interprets the first 20 bytes as a precheck contract address. This contract must implement the precheck interface and is invoked before request fulfillment.

#### Methods

##### precheckCall

Called automatically during the `fulfill` operation to validate arbitrary fulfillment conditions.

**Requirements:**

- Must revert if validation conditions are not met
- Includes the cross chain request and caller address as parameters. Caller is the address of the fulfiller that submitted the transaction to `RIP7755Inbox`.

```solidity
function precheckCall(CrossChainRequest calldata request, address caller) external;
```

### Storage Proof Validation

Storage proof validation implementations are chain-specific, which is why the `claimReward` function in the `Outbox` contract accepts the `proof` parameter as a generic `bytes` type. While specific proof formats may vary between implementations, all must follow this core validation sequence:

![image](../assets/rip-7755/state_root_sharing.png "Storage proof validation")

> [!NOTE]
> Visual elements in diagram:
>
> - Networks: Gray background
> - Contracts: Purple background
> - Storage values: Yellow background
>
> Chain definitions:
>
> - Chain A: Source chain
> - Chain B: Destination chain

Validation Steps:

1. Verify that the proof's beacon root corresponds to the root exposed in Chain A's execution environment.
1. Verify L1 execution client's state root against the beacon root.
1. Verify Chain B's rollup contract storage root against L1 execution client's state root.
1. Verify Chain B's state root against its rollup contract storage root.
1. Verify Chain B's inbox contract storage root against Chain B's state root.
1. Verify the `FulfillmentInfo` struct at the specified storage key against Chain B's inbox contract storage root.

**Important Implementation Note:**
Some L2 chains store an "output root" on L1 instead of directly storing their state root. In these cases, an additional validation step is required between steps 4 and 5. This step must:

1. Provide the destination chain's state root
2. Apply chain-specific logic to derive the output root using the state root and any auxiliary data
3. Verify the derived output root matches the proven value in the destination chain's inbox contract on L1

### Example Usage

These examples demonstrate key functionality of RIP7755. The first example includes detailed explanations that apply to subsequent examples.

#### Cross-Chain Native Asset Transfer

**Scenario: Transferring 0.1 ETH from Address A on Chain X to Address B on Chain Y**

On Chain X, Address A initiates the transfer by calling `requestCrossChainCall` on their chosen `RIP7755Outbox` contract. The request contains a single call:

```solidity
Call({
    to: address(B).toBytes32(),  // Destination address converted to bytes32
    value: 0.1 ether,            // Amount to transfer
    data: ""                     // Empty for simple transfers
})
```

The `CrossChainRequest` specifies:

- Destination chain identifier
- Target `RIP7755Inbox` contract address
- Finality delay (e.g., 7 days to match destination chain's challenge period)
- Reward amount (0.0001 ETH in this example)

When calling to `requestCrossChainCall` on origin chain, the user sends 0.1001 ether in value, which matches `CrossChainRequest.rewardAmount`. The excess above 0.1 ether is intended to exceed the gas cost of the call on destination chain and serve as a compensation to the fulfiller. This reward amount would need to provide sufficient incentive for the fulfiller to wait `CrossChainRequest.finalityDelaySeconds`, in this case 7 days, to get their reward.

#### Adding Fulfiller Exclusivity

**Enhancement: Restricting fulfillment to a specific address for a limited time**

To enhance the previous example, we introduce a precheck condition where Address A authorizes only a specific fulfiller, referred to as Fulfiller A, to submit the transaction to the destination chain for a specified period of time.

To implement this, custom exclusivity logic must be incorporated into a precheck smart contract (PCSM) deployed on the destination chain. The `CrossChainRequest` will include the PCSM address concatenated with the encoded data for exclusivity validation in the `extraData` field.

```solidity
CrossChainRequest({
    // ... other parameters ...
    extraData: abi.encodePacked(
        pcsmAddress,  // Address of precheck contract on destination chain
        abi.encode(
            fulfillerAddress,    // Authorized fulfiller's address
            expirationTimestamp  // End of exclusivity period
        )
    )
})
```

The PCSM enforces that only the authorized fulfiller can execute the transaction before the exclusivity period expires. Attempts by other addresses to call `fulfill` during this period will revert.

### Cross-Chain ERC20 Token Transfer

This guide explains how to transfer ERC20 tokens (e.g., USDC) between different blockchain networks using RIP7755.

#### Overview

To transfer 100 USDC from Address A (Chain X) to Address B (Chain Y), we must address two key requirements:

1. Precise specification of contract calls
2. Execution through the inbox contract

#### Implementation Approaches

##### Approach 1: Known Fulfiller Address

> ⚠️ **Limitations**:
>
> - Limited to a single, pre-determined fulfiller
> - Requires off-chain coordination before execution

###### Origin Chain Operations

1. **Approval Setup**

   ```solidity
   // Address A approves RIP7755Outbox to handle USDC
   USDC.approve(RIP7755Outbox, 100 * (10 ** USDC.decimals()));
   ```

2. **Outbox Call**
   Address A submits two sequential calls via `CrossChainRequest.calls`:

   ```solidity
   // Call 1: Transfer from fulfiller to inbox
   Call({
       to: USDC_CONTRACT_DEST.toBytes32(),
       value: 0,
       data: abi.encodeWithSelector(
           ERC20.transferFrom.selector,
           FULFILLER_ADDRESS,
           RIP7755_INBOX_ADDRESS,
           100 * (10 ** USDC.decimals())
       )
   });

   // Call 2: Transfer from inbox to final recipient
   Call({
       to: USDC_CONTRACT_DEST.toBytes32(),
       value: 0,
       data: abi.encodeWithSelector(
           ERC20.transfer.selector,
           RECIPIENT_ADDRESS_B,
           100 * (10 ** USDC.decimals())
       )
   });
   ```

###### Destination Chain Operations

1. **Fulfiller Approval**

   ```solidity
   // Fulfiller approves RIP7755Inbox to handle USDC
   USDC.approve(RIP7755Inbox, 100 * (10 ** USDC.decimals()));
   ```

2. **Execution**
   ```solidity
   // Fulfiller triggers the transfer sequence
   RIP7755Inbox.fulfill(requestId);
   // 1. USDC moves: Fulfiller -> RIP7755Inbox
   // 2. USDC moves: RIP7755Inbox -> Address B
   ```

##### Approach 2: With helper contract

The challenge can be addressed by implementing a helper contract to manage ERC20 transfers. This contract exposes a method:

```solidity
function transfer(address asset, address to, uint256 amount) external
```

Key characteristics:

- Uses `tx.origin` to determine the source address for `transferFrom` calls
- Validates that `msg.sender` is an authorized `RIP7755Inbox` contract
- Requires fulfillers to either:
  1. Pre-deposit ERC20 tokens in the helper contract, or
  2. Set appropriate token approvals for on-demand transfers

**Implementation Notes:**

> Future specifications may include:
>
> - A reference implementation of the `HelperContract`
> - Support for signature-based fulfiller authentication
> - Optional `context` parameter in `fulfill` calls, maintained by `RIP7755Inbox` during execution

**Flow Example:**

_Origin Chain Setup:_

1. Address A approves `RIP7755Outbox` for 100 USDC
2. Address A submits a cross-chain request with the following call:

```solidity
Call({
    to: destinationUSDCContract.toBytes32(),
    value: 0,
    data: abi.encodeWithSelector(
        HelperContract.transfer.selector,
        CrossChainRequest.rewardAsset,
        addressB,
        100 * (10 ** USDC.decimals())
    )
})
```

_Destination Chain Execution:_

1. Fulfiller approves `HelperContract` for 100 USDC
2. Fulfiller executes `fulfill` on `RIP7755Inbox`, triggering the USDC transfer to Address B via `HelperContract`

## Rationale

Storage-based proof verification for cross-chain call execution provides cryptographic guarantees without introducing additional trust assumptions beyond Ethereum and its rollups. The Inbox contract's immutable storage design ensures that execution receipts, once stored, remain permanent and verifiable at any future time without increasing proof complexity.

The standard converts address types to `bytes32` in both `CrossChainRequest` and `Call` structs to maintain forward compatibility, particularly for future non-EVM chain integrations.

The `extraData` field enables protocol extensibility by supporting:

- Custom pre-check conditions specified by requesters
- Chain-specific validation requirements
- Future protocol enhancements

Independent `rewardAsset` and `rewardAmount` fields provide reward flexibility, allowing:

- Different assets for rewards versus transaction currency
- Example: ETH rewards for USDC transfers
- Fulfiller-side validation of reward adequacy

The separation of `rewardAsset` and `rewardAmount` enables support for diverse reward types independent of the cross-chain transaction currency. For instance, while executing a cross-chain transfer of USDC, the reward could be denominated in ETH. The fulfiller must verify that the reward's value adequately compensates for the transaction costs before processing the call.

The `finalityDelaySeconds` parameter enhances security by ensuring sufficient destination chain finality before proof submission. This security measure can adapt as L1 and L2 consensus mechanisms evolve.

The `l2Oracle` specification enables proof validation reuse across compatible chains. For instance, multiple OP Stack chains can share a single Outbox contract while maintaining separate `l2Oracle` instances.

## Reference Implementation

- [Outbox](../assets/rip-7755/Outbox.md)
- [Inbox](../assets/rip-7755/Inbox.md)

#### Storage Proof Examples

The following library is an example of how storage proof validation can be implemented for an OP Stack chain.

- [OPStackProver](../assets/rip-7755/OPStackProver.md)

Where the `StateValidator` structs are defined as follows:

```solidity
/// @notice Parameters needed to validate the authenticity of Ethereum's execution client's state root
struct StateProofParameters {
    /// @dev The Beacon Chain root published to `BEACON_ROOTS_ORACLE` on this L2 chain
    bytes32 beaconRoot;
    /// @dev The timestamp associated with the provided Beacon Root
    uint256 beaconOracleTimestamp;
    /// @dev The state root of Ethereum's execution client
    bytes32 executionStateRoot;
    /// @dev A proof to verify the authenticity of `executionStateRoot`
    bytes32[] stateRootProof;
}

/// @notice Parameters needed to validate the authenticity of an EVM account's storage
struct AccountProofParameters {
    /// @dev The storage location to validate
    bytes storageKey;
    /// @dev The expected value at the specified storage location
    bytes storageValue;
    /// @dev A proof used to derive an account's storage root
    bytes[] accountProof;
    /// @dev A proof to validate the account's `storageValue` at `storageKey` location
    bytes[] storageProof;
}
```

This implementation example is designed with the assumption that the chain it is deployed on supports EIP-4788. It adheres to the general storage proof validation pattern previously outlined. The following lines highlight the specifics that are unique to the OP Stack:

```solidity
bytes32 version;
// Extract the L2 stateRoot and timestamp from the RLP-encoded block array
(bytes32 l2StateRoot, uint256 l2Timestamp) = proofData.encodedBlockArray.extractStateRootAndTimestamp();
// Derive the L2 blockhash
bytes32 l2BlockHash = proofData.encodedBlockArray.toBlockHash();

// Compute the expected destination chain output root (which is the value we just proved is in the L1 storage slot)
bytes32 expectedOutputRoot =
    keccak256(abi.encodePacked(version, l2StateRoot, proofData.l2MessagePasserStorageRoot, l2BlockHash));
// If this checks out, it means we know the correct l2StateRoot
if (bytes32(proofData.dstL2StateRootProofParams.storageValue) != expectedOutputRoot) {
    revert InvalidL2StateRoot();
}
```

This example leverages Optimism's `AnchorStateRegistry` contract to utilize the most recent anchor state available at the time of proof. The anchor state represents the finalized state of the destination L2 chain. To verify the state root of the destination chain, we must provide the pre-image of the chain's anchor state output root. As of this writing, the pre-image consists of four `bytes32` values: `version`, `l2StateRoot`, `l2MessagePasserStorageRoot`, and `l2BlockHash`.

The `l2StateRoot` and `l2BlockHash` are extracted and derived from the RLP-encoded block headers array. Specifically, the `l2StateRoot` is the fourth element in this array, while the `l2BlockHash` is the hash of the entire RLP-encoded block headers array. With this information, we can compute the expected output root.

If the derived output root does not match the value stored in the L1 storage slot, the proof is deemed invalid.

#### Arbitrum

The following library is an example of how storage proof validation can be implemented for Arbitrum.

- [ArbitrumProver](../assets/rip-7755/ArbitrumProver.md)

The process of verifying this proof is similar to the OP Stack example, but with specific nuances for Arbitrum. Below are the lines of code that are tailored for Arbitrum's unique architecture:

```solidity
// Derive the L2 blockhash
bytes32 l2BlockHash = proofData.encodedBlockArray.toBlockHash();
// Derive the RBlock's `confirmData` field
bytes32 confirmData = keccak256(abi.encodePacked(l2BlockHash, proofData.sendRoot));
// Extract the L2 stateRoot and timestamp from the RLP-encoded block array
(bytes32 l2StateRoot, uint256 l2Timestamp) = proofData.encodedBlockArray.extractStateRootAndTimestamp();

// The L1 storage value we proved was the node's confirmData
if (bytes32(proofData.dstL2StateRootProofParams.storageValue) != confirmData) {
    revert InvalidConfirmData();
}
```

In Arbitrum, the `confirmData` field within an RBlock is utilized as the L1 storage value that we have proven. Similar to the OP Stack example, we must derive the expected storage value on L1 using the state root. Specifically, this is achieved by hashing the `l2BlockHash` together with the `sendRoot` found in the proof data structure. Given that the L2 state root is included in the pre-image of the block hash, a match between the derived value and the verified storage value confirms the authenticity of the state root.

## Security Considerations

### Storage Proof Validation Risks

Hard forks in any chain can compromise storage proof validation compatibility. This incompatibility may arise from:

- Changes to the chain's state layout (e.g., migration from Merkle Patricia Trie storage)
- Modifications to L1 data storage mechanisms

**Critical Impact**: Incompatible storage proof validation can result in locked funds in Outbox contracts. Implementations must include disaster recovery procedures to mitigate this risk.

### Inbox Contract Trust Considerations

When integrating with RIP-7755 on destination chains, developers must evaluate the trust implications of direct Inbox contract calls. Latency-optimized Inbox implementations may execute requests before source chain finalization, potentially bypassing origin chain validation.

**Security Recommendations**:

- For non-sensitive operations: Direct Inbox contract calls may be acceptable
- For sensitive operations: Implement an authentication protocol layer between the Inbox contract and destination smart contract

## Fulfiller Risk Management

The system architecture shifts primary risk exposure from users to fulfillers. Key risks include:

1. **Reorg Risk**: Immediate request fulfillment exposes fulfillers to potential source chain reorganizations, which may result in:

   - Transaction reversals
   - Token transfer losses

2. **Request Validation Requirements**

At a minimum, fulfillers must validate all requester-set fields against these criteria:

| Field                  | Validation Requirements                                                               |
| ---------------------- | ------------------------------------------------------------------------------------- |
| `calls`                | Must contain at least one valid call                                                  |
| `destinationChainId`   | Must match fulfiller's supported chains                                               |
| `inboxContract`        | Must reference a verified destination chain inbox contract                            |
| `l2Oracle`             | Must reference a valid L2 oracle contract for the destination chain                   |
| `rewardAsset`          | Must be either a valid ERC20 token or supported native asset                          |
| `rewardAmount`         | Must cover: total `calls` value + gas costs + `finalityDelaySeconds` opportunity cost |
| `finalityDelaySeconds` | Must exceed destination chain's finality delay                                        |

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
